<html>
<head>
  <title>22.- Explain good relational design</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/301769 (en-US); Windows/10.0.14342 (Win64);"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1034"/>
<h1>22.- Explain good relational design</h1>

<div>
<span><div>22.- Explain good relational design</div><div><br/></div><div><br/></div><div><div style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-weight: bold; font-size: 20px;"><div><font size="+2">The Relational Model</font></div></div><ul style="color: rgb(0, 0, 0); font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><li>All data are represented as tables (relations)</li><li>Tables are comprised of rows and columns (tuples)</li><li>Rows are (officially) unordered (i.e., the order in which rows are referenced does not matter)</li><li>A proper relational table contains <b>no duplicate rows.</b></li><li>Each table has a <b>primary key, </b>a unique identifier constructed from one or more columns</li><li>Most primary keys are a single column (e.g., OWNERNUM for OWNERS)</li><li>A table is linked to another by including the other table's primary key. Such an included column is called a <b>foreign key</b></li></ul></div><div><br/></div><div><div style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-weight: bold; font-size: 20px;"><div><font size="+2">Qualities of a Good Database Design</font></div></div><ul style="color: rgb(0, 0, 0); font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><li>Reflects real-world structure of the problem</li><li>Can represent all expected data over time</li><li>Avoids redundant storage of data items</li><li>Provides efficient access to data</li><li>Supports the maintenance of data integrity over time</li><li>Clean, consistent, and easy to understand</li><li><i>Note: These objectives are sometimes contradictory!</i></li></ul><h2 style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a name="Introduction_to_Entity-Relationship_Modeling"></a><font size="+2">Introduction to Entity-Relationship Modeling</font></h2><ul style="color: rgb(0, 0, 0); font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><li>Entity-Relationship (E-R) Modeling: A method for designing databases</li><li>A simplified version is presented here</li><li>Represents the data by <b>entities</b> that have <b>attributes</b>.</li><li>An entity is a class of distinct identifiable objects or concepts</li><li>Entities have <b>relationships</b> with one another</li><li>Result of the process is a <b>normalized </b>database that facilitates access and avoids duplicate data</li><li>Here's an ER diagram of portions of the 'parcels' test database. It is drawn by importing the tables from Oracle to MS-Access and then using the Tool/Relationships capability of MS-Access to draw the diagrams:</li></ul><blockquote style="color: rgb(0, 0, 0); font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><p><img height="356" src="http://web.mit.edu/11.521/www/lectures/lecture10/er_diag.jpg" style="height: auto;" width="477"></img></p></blockquote><h2 style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a name="E-R_Modeling_Process"></a><font size="+2">E-R Modeling Process</font></h2><ul style="color: rgb(0, 0, 0); font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><li>Identify the entities that your database must represent</li><li>Determine the cardinality relationships among the entities and classify them as one of</li><li style="list-style: none; display: inline"><ul><li>One-to-one (e.g., a parcel has one address)</li><li>One-to-many (e.g., a parcel may be involved in many fires)</li><li>Many-to-many (e.g., parcel sales: a parcel may be sold many times by different owners, and an individual owner may sell many parcels)</li></ul></li><li>Draw the entity-relationship diagram</li><li>Determine the attributes of each entity</li><li>Define the (unique) primary key of each entity</li><li>Define the relationships between primary keys in one table and foreign keys in another</li></ul><h2 style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a name="From_E-R_Model_to_Database_Design"></a><font size="+2">From E-R Model to Database Design</font></h2><ul style="color: rgb(0, 0, 0); font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><li>Entities with one-to-one relationships can (and often should) be merged into a single entity</li><li>Each remaining entity is modeled by a table with a primary key and attributes, some of which may be foreign keys</li><li>One-to-many relationships are modeled by a foreign key attribute in the table representing the entity on the &quot;many&quot; side of the relationship (e.g., the FIRES table has a foreign key that refers to the PARCELS table)</li><li>Many-to-many relationships among two entities are modeled by defining a <strong>third</strong> table that has foreign keys that refer to the entities in each original table. These foreign keys should be included in the third table's primary key, if appropriate</li><li>Commercially available tools can automate the process of converting a E-R model to a database schema</li></ul><h2 style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a name="Database_Normalization"></a>Database Normalization</h2></div><div><br/></div><div><div style="color: rgb(0, 0, 0); font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div>Much of formal database design is focused on <b>normalizing</b> the database and ensuring that the design conforms to a <b>level of normalization</b> (e.g., first normal form, second normal form, etc.).<b> </b>Although there are higher normal forms, <b>Third Normal Form</b> is generally considered good enough for typical applications. Normalization generally involves taking a design with fewer tables and many columns and transforming it into a design with more tables with fewer columns -- after conducting some tests and applying some rules. <strong>First normal form</strong>s requires that there be no multi-valued attributes (e.g., for the URISA database, do not put multiple keyword codes in the same cell, and do not have keyword1, keyword2, etc. columns). <strong>Second Normal Form</strong> requires that non-key fields must be dependent upon the entire key (e.g., don't put the owner name as well as an owner ID in the parcel table). <strong>Third Normal Form</strong> prohibits transitive dependencies whereby a non-key attribute is dependent on another non-key attribute (e.g., only put a unique owner ID in the parcel table and not any other owner information such as their age or mailing address). Here are some online sites with useful database management concepts and tips including some good discussion of database normalization: and first, second, and third normal form: (In particular, PHPBuilder has understandable examples of the different levels of normalization.)</div></div><div><br/></div><h2 style="color: rgb(0, 0, 0); font-style: normal; font-variant: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a name="Database_Design_Rules_of_Thumb"></a><font size="+2">Review: Database Design Rules of Thumb</font></h2><ul style="color: rgb(0, 0, 0); font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><li>Keep data items atomic (e.g., first and last names are separate). Concatenating columns together later on-the-fly is generally easy, but separating them is not. (First Normal Form)</li><li style="list-style: none; display: inline"><ul><li><i>What is an example of where parsing subfields from a column may go awry?</i></li><li><i>When might you want to include the combined fields in a column anyway?</i></li></ul></li><li>Define the primary key first. Use a descriptive name (PARCELID, not ID)</li><li>In fact, use descriptive names that give a new user a decent chance of guessing what they mean for <i>all</i> your columns! (E.g., use PARCEL_COUNT rather than PACT)</li><li>Use a single column for the primary key whenever possible; multi-column primary keys are appropriate for many-to-many relationships</li><li>Use lookup tables rather than storing long values</li><li>Use numeric keys whenever possible <i>(What about ZIP codes?)</i></li><li>Avoid intelligent keys (exception: lookup tables)</li><li>Avoid using multiple columns to represent a one-to-many relationship (e.g., columns such as CHILD1, CHILD2 in a table called PARENT rather than putting the children in a separate table. (First Normal Form)</li><li>For readability, use the primary key name for foreign keys unless the same foreign key is used multiple times in the same table (e.g., state of work and state of residence for a person might both be foreign keys that reference a table of states)</li><li>Do not include two columns whose values are linked together (e.g., county name and county ID) unless one of the columns is the primary key of the table (Third Normal Form)</li><li>Avoid allowing NULL values in columns that have a discrete range of possible values (e.g., integers between 1 and 10, inclusive)</li><li style="list-style: none; display: inline"><ul><li><em>Not applicable to DBF files, which do not support NULLs</em></li></ul></li><li>Avoid using multiple tables with similar structures that represent minor variants on the same entity (e.g., putting Boston parcels and Cambridge parcels in separate tables).</li><li style="list-style: none; display: inline"><ul><li><i>Why is this rule often hard to practice with GIS?</i></li></ul></li><li>Plan ahead for transferring data to a different database. For example, you may want to move data from Oracle to DBF, or Microsoft Access to Oracle.</li><li style="list-style: none; display: inline"><ul><li>Avoid column names with characters with other than UPPER CASE letters (A-Z), digits (0-9), and the underscore (_). Other characters may not be accepted by a database. Some database systems may be case sensitive with regard to column names, while others are not.</li><li>Keep your column names relatively short. Different databases support different numbers of characters in column names (e.g., 30 for Oracle, 64 for Microsoft Access, 10 for DBF). Try to make column names differ in the first few characters rather than at the end to avoid column name duplication if the names are truncated during the conversion process (e.g., use COL1 and COL2, not LONG_COLUMN_NAME_1 and LONG_COLUMN_NAME_2).</li><li><i>Note that keeping column names short may be at odds with keeping your column names meaningful for neophytes. Be aware that you are making a tradeoff!</i></li></ul></li><li>Remember that these are rules of thumb, <i>not</i> absolute laws! Bend the rules if you must but have a justification for your decision. The limitations of a GIS software package often provide a good reason.</li></ul></div><div><br/></div></span>
</div></body></html> 